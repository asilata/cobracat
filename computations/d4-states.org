#+property: header-args:sage :session d4-states :eval never-export :exports both
#+title: PPTs and states for type D4

* Setup for D4
Load libraries and set \(D_4\) as the Cartan type.
#+name: d4-dynkin
#+begin_src sage :results silent
  import itertools
  load("setup_cartan.sage")
  ct = CartanType("D4")
  ct.dynkin_diagram()
  indices = ct.dynkin_diagram().vertices()
#+end_src

The resulting Dynkin diagram looks like this; note that \(2\) is the central vertex.
#+begin_example
    O 4
    |
    |
O---O---O
1   2   3   
D4
#+end_example



Now set up the following dictionaries:
- ~p~ is a dictionary of the indecomposable projectives, indexed by the vertices of the Dynkin diagram;
- ~s~ is a dictionary of the spherical twists and their inverses, indexed by the vertices of the Dynkin diagram and their negatives.

  #+begin_src sage :results silent
    p, s, _ = zz_setup(ct)
  #+end_src

Record the simple roots of type \(D_4\).
#+begin_src sage :results silent
  simples = ct.root_system().root_lattice().simple_roots()
  positives = ct.root_system().root_lattice().positive_roots()
#+end_src

* Expansive motions business
Write down a matrix of coefficients of simple roots for each positive root of the root system.
#+begin_src sage :results silent
  root_matrix = matrix([[r.coefficient(i) for i in indices] for r in positives])
#+end_src

Create variables to represent coordinates for the velocity vectors of the simple roots.
#+begin_src sage :results silent
  simple_velocities = matrix([[var('a' + str(i)), var('b' + str(i))] for i in indices])
#+end_src

Initialise a particular central charge. At the moment we are making up some "good" numbers.
WARNING: this part of the code is particular to type \(D_4\)!
#+begin_src sage :results silent
  simple_ccs_d4 = matrix([vector([-2,1]), vector([20,1]), vector([-2,2]), vector([-1,2])])
#+end_src

Now compute the central charges and (indeterminate) velocities for all the positive roots.
#+begin_src sage :results silent
  positive_ccs = root_matrix * simple_ccs_d4
  positive_velocities = root_matrix * simple_velocities
#+end_src

** Expansive inequalities and polytope of expansive motions
The various inequalities are of the form \(\langle z, v \rangle \ge 0\), where \(z\) is a central charge vector and \(v\) is the corresponding velocity vector.
We create a list of inequalities (in a form acceptable to sage), and then construct a polyhedron defined by these inequalities over \(\mathbb{Q}\).
#+begin_src sage :results silent
  def eq_to_ieq(expr):
       return [0] + [expr.coefficient(x) for x in simple_velocities.list()]

  ineqs = [eq_to_ieq(x.dot_product(y)) for (x,y) in zip(positive_velocities, positive_ccs)]

  P = Polyhedron(ieqs = ineqs, base_ring=QQ)
#+end_src

** Computations on extremal rays
Recall that an extremal ray consists of the \(x\) and \(y\) coordinates for each of the velocity vectors.
The following function converts an extremal ray into a matrix of velocities, by splitting the list into pieces of size \(2\) and then converting the output into a matrix.
#+begin_src sage :results silent
  def ray_to_velocity_matrix(r):
      return matrix([r[i:i+2] for i in range(0,len(r),2)])
#+end_src

A matrix of velocities corresponding to an extremal ray specifies how each point moves so that we get an infinitesimally expansive motion.
The central charge vectors that remain rigid (do not expand) are exactly the ones whose velocity vector have zero dot product with the corresponding central charge vector.
The collection of these central charge vectors forms (the closure of) a state, namely the appropriate analogue of a pointed pseudo-triangulation without an external edge.
Among these, some subcollections form rigid components: these are distinguished by the fact that they all have the same ratio of the length of the velocity vector to the length of the central charge vector.

The following function produces a list of rigid components given an extremal ray.
#+begin_src sage :results silent
  def rigid_components(ray):
      velocities = root_matrix * ray_to_velocity_matrix(ray)
      rigid_roots_ratios = [(ray,x.norm()/y.norm())
                            for (ray,x,y) in zip(positives,velocities, positive_ccs) if x.dot_product(y) == 0]
      unique_ratios = set(t[1] for t in rigid_roots_ratios)
      components = []
      for ratio in unique_ratios:
          this_component = []
          for t in rigid_roots_ratios:
              if t[1] == ratio:
                  this_component.append(t[0])
          components.append(this_component)

      return components
#+end_src

** Results
First we draw the stability condition we have constructed.
#+begin_src sage :results file :exports both
  sum([plot(x) + text(y, x + vector([0,0.5]))
       for (x,y) in zip(positive_ccs, positives)])
#+end_src

#+RESULTS:
[[file:/tmp/tmpjexuzurg/tmp_4q86gr7g.png]]

Next we compute the rigid components for each of the extremal rays of the polyhedron \(P\).
#+begin_src sage :exports both :results silent
  collapsed_components = [rigid_components(r) for r in P.ray_generator()]
  collapsed_states = [flatten(x) for x in collapsed_components]
#+end_src

Let us try to tease out the "real" states from the collapsed states.
We start with the list of 6-element collapsed states: these are certainly real.
Make them all sets for ease of comparison and intersections.
#+begin_src sage :results silent
  original_states = set([frozenset(x) for x in collapsed_states if len(x) == 6])
#+end_src

Now consider all collapsed states, and look at all potential 6-element subsets of them.
#+begin_src sage :results silent
  potential_states = set(sum([[frozenset(x) for x in itertools.combinations(s,6)] for s in collapsed_states], []))
#+end_src

#+begin_src sage :results silent
  def flips(state, potential_states):
      for x in state:
          sub_state = state - set([x])
          flips = [s for s in potential_states if sub_state & s == sub_state]
          print(flips)
#+end_src

* A stability condition

A helper function to compute the root class of any given projective complex.
#+begin_src sage :results silent
  def obj_to_root(obj):
      proj_dict = dict([(k,0) for k in p.keys()])
      for d in range(obj.minIndex(), obj.maxIndex()+1):
          for x in obj.objects(d):
              proj_key = x._i
              proj_dict[proj_key] = proj_dict[proj_key] + (-1)**(d - x.twist())
      return sum([proj_dict[k] * simples[k] for k in proj_dict])
#+end_src

A helper function to print a short name for an object
#+begin_src sage :results silent
  def short_name(obj):
      root = obj_to_root(obj)
      return "".join([str(root.coefficient(i)) for i in indices])
#+end_src

Define the stability condition "by hand".
#+begin_src sage :results silent
  stab = [p[2], s[1](p[2]), s[4](p[2]), s[3](p[2]), internalTwist(s[-2](s[-1](s[-4](s[-3](p[2])))),-4).shift(4), s[1](s[4](p[2])), s[1](s[3](p[2])), s[4](s[3](p[2])), s[1](s[4](s[3](p[2]))), p[4], p[3], p[1]]
#+end_src

A helper function to compute the stable object of a given positive root class.
#+begin_src sage :results silent
  def root_to_stable_obj(root):
      for x in stab:
          if obj_to_root(x) == root:
              return x
      return None
#+end_src

A helper function to compute the phase of the stable object.
#+begin_src sage :results silent
  def obj_to_phase(obj):
      """
      Given a list of central charge vectors of all the positive roots
      """
      root = obj_to_root(obj)
      root_cc = [x[1] for x in zip(positives, positive_ccs) if x[0] == root][0]
      return arg(root_cc[0] + I * root_cc[1])/pi
#+end_src

A helper function to list all the homs between stables as well as their phases.
This is in order to discover the convex and reflex morphisms with factorings.
#+begin_src sage :results silent
  def homs_with_phases():
      homs_phases_list = []
      for i in range(0, len(stab)):
          for j in range(0, len(stab)):
              xi,xj = stab[i], stab[j]
              p = float(obj_to_phase(xj) - obj_to_phase(xi))
              hij = hom(xi,xj)
              hij.minimize()
              hij_degrees = sum([[k - l._grade for l in hij.objects(k)] for k in range(hij.minIndex(), hij.maxIndex()+1)], [])
              new_homs_phases = [(xi,xj,p + d) for d in hij_degrees]
              homs_phases_list = homs_phases_list + new_homs_phases
      return homs_phases_list      
#+end_src

Helper function to generate the "minimal morphism" graph.
#+begin_src sage :results silent
  def minimal_morphism_graph():
      hwp = homs_with_phases()
      edges = [(short_name(x[0]), short_name(x[1]), x[2]) for x in hwp if x[0] != x[1]]
      G1 = DiGraph(edges)
      G = DiGraph()
      
      print(len(edges))
      # Only add minimal edges to G.
      for e in G1.edges():
          start, end, weight = e[0], e[1], e[2]
          # Assume that e is minimal until proven otherwise.
          e_is_minimal = True

          for p in G1.all_paths_iterator([start], [end], max_length = 3, report_edges=True, labels=True):
              # Find out if e factors. if it does, a length-two path will be a witness to the factoring.
              if len(p) == 1:
                  # Path too short.
                  continue
              if not abs(sum([f[2] for f in p]) - weight) < 0.0001:
                  # Weights don't sum to our weight
                  continue
              else:
                  # e is not minimal; abort loop.
                  e_is_minimal = False
                  break
              
          if e_is_minimal:
              G.add_edge(e)
              
      return G
#+end_src

Helper function to check if a graph has the "no-convex-factoring" property.
#+begin_src sage :results silent
  def no_convex_factoring_property(G):
      reflex_edges = [e for e in G.edges() if e[2] > 1]

      for e in reflex_edges:
          start, end, weight = e[0], e[1], e[2]
          for p in G.all_paths_iterator([start], [end], max_length = 3, report_edges=True, labels=True):
              if len(p) == 1:
                  # Path too short
                  continue
              if not all([f[2] < 1 for f in p]):
                  # The path is not totally convex.
                  continue
              if not abs(sum([f[2] for f in p]) - weight) < 0.0001:
                  # Weights don't sum to our weight.
                  continue
              else:
                  return False
      return True      
#+end_src

Helper function to return all subgraphs of a given graph that have the "no-convex-factoring" property.
#+begin_src sage :results silent
  def no_convex_factoring_subgraphs(G):
      result = []

      # start with one-vertex subsets of G.
      current_results = dict([(frozenset([x]), set()) for x in G.vertices()])
      new_results = {}
      done_p = False

      while not done_p:
          for s in current_results:
              subgraph, incompatibles = s, current_results[s]
              print(subgraph, incompatibles)
              # If each vertex of G is either in the subgraph or in the incompatibles, move on.
              if set(G.vertices()) == subgraph | incompatibles:
                  continue

              # Consider the subgraph of G generated by the "subgraph" vertices.
              #H = G.subgraph(subgraph)

              for v in G.vertices():
                  if v in subgraph or v in incompatibles:
                      continue

                  # If we already know about the current subgraph, continue
                  if subgraph in current_results and (incompatibles | set([v])).issubset(current_results[subgraph]):
                      continue
                  if subgraph in new_results and (incompatibles | set([v])).issubset(new_results[subgraph]):
                      continue

                  # Add on v to create a new subgraph to check.
                  new_subgraph = subgraph | set([v])

                  # If we already know about this new subgraph, merge existing knowledge and continue.
                  if new_subgraph in current_results or new_subgraph in new_results:
                      new_results[new_subgraph] = new_results.get(new_subgraph, set()) | current_results.get(new_subgraph, set())
                      continue
                  
                  # Otherwise, create an actual subgraph of G to check.
                  H = G.subgraph(new_subgraph)
                  if no_convex_factoring_property(H):
                      print("FOUND ONE:", H.vertices())
                      new_results[new_subgraph] = new_results.get(new_subgraph, set()) | incompatibles
                  else:
                      new_results[subgraph] = new_results.get(subgraph, set()) | incompatibles | set([v])
                      
          if new_results == current_results:
              done_p = True
          else:
              print("---------")
              print("CHANGING ITERATION")
              for s in new_results:
                  current_results[s] = current_results.get(s, set()) | new_results[s]

              current_results = {k:current_results[k] for k in new_results}
              print(len(new_results))

      return new_results
#+end_src

#+RESULTS:

Helper function to check if a graph has the property that it has no minimal reflex cycles.
#+begin_src sage :results silent
  def no_min_reflex_cycles(G):
      reflex_edges = [e for e in G.edges() if e[2] > 1]
      min_reflex_edges = []

      for e in reflex_edges:
          # Check if e is non-minimal.
          start, end, weight = e[0], e[1], e[2]
          e_is_minimal_reflex = True
          for p in G.all_paths_iterator([start], [end], max_length = 3, report_edges=True, labels=True):
              # If the edge e has a convex/reflex factoring, then a factoring of length 2 is a witness to it.
              if len(p) == 1:
                  # Path too short
                  continue
              if not any([f[2] > 1 for f in p]):
                  # The path does not have a reflex morphism along it
                  continue
              if not abs(sum([f[2] for f in p]) - weight) < 0.0001:
                  # Weights don't sum to our weight
                  continue
              else:
                  e_is_minimal_reflex = False
                  break
              
          # If e is minimal reflex, add it to our list.
          if e_is_minimal_reflex:
              min_reflex_edges.append(e)

      #Build a graph on the minimal reflex edges only.
      G1 = DiGraph(min_reflex_edges)
      return G1.is_directed_acyclic()
#+end_src

Function to compute the Euler characteristic of the simplicial complex formed by a collection of sets.
#+begin_src sage :results silent
  def powerset(iterable):
    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s)+1))

  def euler_characteristic(sc):
      all_elements = set(sum([[frozenset(y) for y in powerset(x)] for x in sc], []))
      euler_char = 0
      return sum([(-1)**len(x) for x in all_elements if len(x) > 0])
        #+end_src

Helper function to compute the flip graph formed by a collection of sets.
#+begin_src sage :results silent
  def flip_graph(sc):
      sc = list([frozenset(x) for x in sc])
      edges = []
      for i in range(0, len(sc)):
          for j in range(0,i):
              if len(sc[i] & sc[j]) == len(sc[i]) - 1:
                  edges.append((sc[i], sc[j]))
      return Graph(edges)
#+end_src

* States
This is copied over from the d4-motions file.
#+begin_src sage :results silent
  X1 = p[1]
  X2 = p[4]
  X3 = p[3]
  Y1 = s[4](s[3](p[2]))
  Y2 = s[1](s[3](p[2]))
  Y3 = s[1](s[4](p[2]))
  Z1 = s[1](p[2])
  Z2 = s[4](p[2])
  Z3 = s[3](p[2])
  A = s[-2](s[-1](s[-4](s[-3](p[2]))))
  B = p[2]
  C = s[1](s[4](s[3](p[2])))
  Xs = {1:X1, 2:X2, 3:X3}
  Ys = {1:Y1, 2:Y2, 3:Y3}
  Zs = {1:Z1, 2:Z2, 3:Z3}  
#+end_src

#+begin_src sage :results silent
  type1_states =[
      [Xs[p(1)], Xs[p(2)], Ys[p(1)], Ys[p(3)], Zs[p(2)], Zs[p(3)]]
        for p in SymmetricGroup(3)
  ]
#+end_src

#+begin_src sage :results silent
  type2_states = [[B, Xs[p(1)], Xs[p(2)], Zs[p(2)], Zs[p(3)], Ys[p(1)]]     for p in SymmetricGroup(3)] +  [[B, Xs[p(1)], Xs[p(2)], Zs[p(2)], Zs[p(3)], Ys[p(3)]]     for p in SymmetricGroup(3)] +  [[C, Ys[p(1)], Ys[p(2)], Xs[p(2)], Xs[p(3)], Zs[p(1)]]     for p in SymmetricGroup(3)] +  [[C, Ys[p(1)], Ys[p(2)], Xs[p(2)], Xs[p(3)], Zs[p(3)]]     for p in SymmetricGroup(3)] +  [[A, Zs[p(1)], Zs[p(2)], Ys[p(2)], Ys[p(3)], Xs[p(1)]]     for p in SymmetricGroup(3)] +  [[A, Zs[p(1)], Zs[p(2)], Ys[p(2)], Ys[p(3)], Xs[p(3)]]     for p in SymmetricGroup(3)]
  #+end_src

#+begin_src sage :results silent
  all_states = type1_states + type2_states
  all_states_as_roots = [[obj_to_root(x) for x in s] for s in all_states]
#+end_src

#+begin_src sage :results silent
  flipgraph_edges = [(all_states_as_roots[i], all_states_as_roots[j]) for i in range(0, len(all_states_as_roots)) for j in range(0,i) if len(set(all_states_as_roots[i]) & set(all_states_as_roots[j])) == 5]
  flipgraph_edges = [(frozenset(x), frozenset(y)) for (x,y) in flipgraph_edges]
  flip_graph = Graph(flipgraph_edges)
#+end_src

