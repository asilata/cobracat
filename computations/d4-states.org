#+property: header-args:sage :tangle "d4-states.sage" :session d4-states :eval never-export :exports both
#+title: PPTs and states for type D4

* Setup for D4
Load libraries and set \(D_4\) as the Cartan type.
#+name: d4-dynkin
#+begin_src sage :results silent
  import itertools
  load("setup_cartan.sage")
  ct = CartanType("D4")
  indices = ct.dynkin_diagram().vertices()
#+end_src

The resulting Dynkin diagram looks like this; note that \(2\) is the central vertex.
#+begin_example
    O 4
    |
    |
O---O---O
1   2   3   
D4
#+end_example

Now set up the following dictionaries:
- ~p~ is a dictionary of the indecomposable projectives, indexed by the vertices of the Dynkin diagram;
- ~s~ is a dictionary of the spherical twists and their inverses, indexed by the vertices of the Dynkin diagram and their negatives.

  #+begin_src sage :results silent
    p, s, _ = zz_setup(ct)
  #+end_src

Record the simple and positive roots of type \(D_4\).
#+begin_src sage :results silent
  simples = ct.root_system().root_lattice().simple_roots()
  positives = ct.root_system().root_lattice().positive_roots()
#+end_src

The coefficients of roots in terms of simple roots.
#+begin_src sage :results silent
  root_matrix = matrix([[r.coefficient(i) for i in indices] for r in positives])
#+end_src

** Useful helper functions
A helper function to compute the root class of any given projective complex.
#+begin_src sage :results silent
  def obj_to_root(obj):
      proj_dict = dict([(k,0) for k in p.keys()])
      for d in range(obj.minIndex(), obj.maxIndex()+1):
          for x in obj.objects(d):
              proj_key = x._i
              proj_dict[proj_key] = proj_dict[proj_key] + (-1)**(d - x.twist())
      return sum([proj_dict[k] * simples[k] for k in proj_dict])
#+end_src

A helper function to return a short name for a root.
#+begin_src sage :results silent
  def short_name_root(root):
      return "".join([str(root.coefficient(i)) for i in indices])
#+end_src

A helper function to print a short name for an object.
#+begin_src sage :results silent
  def short_name(obj):
      root = obj_to_root(obj)
      return short_name_root(root)
#+end_src

* Indecomposable spherical objects in the heart
We will begin by generating all indecomposable spherical objects in the standard heart.

First, a few helper functions. Check if a given object lies in the standard heart.
#+begin_src sage :results silent
  def in_heart(obj):
      """
      Return True if and only if the given object is in the standard heart; that is, if it is a linear complex.
      """
      for i in range(obj.minIndex(), obj.maxIndex()+1):
          obj_i = obj.objects(i)
          for x in obj_i:
              if x.twist() != i:
                  return False
      return True
#+end_src

Check if two given objects are equal up to shift.
#+begin_src sage :results silent
  def equal_upto_shift(x,y):
      """
      Check if objects x and y are equal up to shift.
      """
      xmin, xmax = x.minIndex(), x.maxIndex()
      ymin, ymax = y.minIndex(), y.maxIndex()
      if xmax - xmin != ymax - ymin:
          return False

      for i in range(0, xmax - xmin + 1):
          xi, yi = x.objects(i + xmin), y.objects(i + ymin)
          if len(xi) !=  len(yi):
              return False
          if sorted([a.name() for a in xi]) != sorted([a.name() for a in yi]):
              return False
      return True
#+end_src

Helper functions to generate the braid words that we want to apply in order to get all objects in the heart.
#+begin_src sage :results silent
  W = WeylGroup(ct)

  def all_signed_combinations(w):
      """
      Return a list of all possible signed lifts of a given word w in the Weyl group.

      INPUT:
      - w, a word in the Weyl group, for example [1,2]

      OUTPUT:
      - a list of all possible signed versions of the given word. In the previous example that would be [[1,2], [-1,2], [1,-2], [-1,-2]].
      """
      current_signed_lifts = [[]]
      current_word = w

      while(len(current_word) > 0):
          new_signed_lifts = []
          current_letter = current_word[0]
          current_word = current_word[1:]
          for v in current_signed_lifts:
              new_signed_lifts.append(v + [current_letter])
              new_signed_lifts.append(v + [-current_letter])
          current_signed_lifts = new_signed_lifts
      return current_signed_lifts

#+end_src
Generate and return all indecomposable sphericals in the standard heart.
#+begin_src sage :results silent
  def indecomposable_sphericals_in_heart():
      """
      Return a list of all the spherical objects in the standard heart of the 2-CY category associated to the chosen Cartan type.
      This list checks if the generated object at any stage is equal (up to shift) to any previously generated object, and only adds it to the outputs if not already present.
      Thus the returned list should contain no duplicates.
      """
      # Collect all signed combinations of all reduced words in the Weyl group.
      reduced_words = sorted([x.reduced_word() for x in WeylGroup(ct)], key=len)
      reduced_braid_words = sum([all_signed_combinations(w) for w in reduced_words], [])
      long_word_length = max([len(x) for x in reduced_words])    
      

      # Start with the list of reduced braid words; this will be pruned as we go.
      pruned_braid_words = reduced_braid_words
      outputs = []

      # Go through words by length, applying the word to p[1] and checking if it is in the heart.
      # If it is in the heart, then add it to outputs.
      # Otherwise, prune the remaining braid words by removing any word that has the current word as a rightmost substring.
      for l in range(0,long_word_length + 1):
          print("Applying words of length {}.".format(l))
          lifts_of_length_l = [x for x in pruned_braid_words if len(x) == l]
          pruned_braid_words = [x for x in pruned_braid_words if len(x) > l]
          
          for b in lifts_of_length_l:
              b_of_p1 = composeAll([s[i] for i in b])(p[1])
              if in_heart(b_of_p1):
                  exist_equal_elements = False
                  for x in outputs:
                      if equal_upto_shift(x,b_of_p1):
                          exist_equal_elements = True
                          break

                  if not exist_equal_elements:
                      outputs = outputs + [b_of_p1]
              else:
                  pruned_braid_words = [x for x in pruned_braid_words if x[-len(b):] != b]
      return outputs
#+end_src

* Central charges and stable objects
We can write down a central charge on the standard heart by specifying a vector in the upper half plane for each simple root.

A helper function to compute the phase of an object.
The central charge is specified as a dictionary with keys the vertices of the Dynkin diagram, and values the values of the central charge on the corresponding simple root.
#+begin_src sage :results silent
  def obj_to_phase(obj, cc):
      """
      Given a list of central charge vectors of all the positive roots
      """
      root = obj_to_root(obj)
      positive_ccs = root_matrix * vector(cc.values())
      
      root_cc = [x[1] for x in zip(positives, positive_ccs) if x[0] == root][0]
      return float(arg(root_cc)/pi)
#+end_src

Given a central charge, we can figure out which of the indecomposable spherical objects in the heart are semistable.
#+begin_src sage :results silent
  def semistable_objects(cc, heart):
      known_stables = []
      heart_by_length = sorted(heart, key=lambda x: obj_to_root(x).length())

      def exists_hom_zero(y,x):
          """
          Return true if there is at least one degree-zero hom from object y to object x.
          """
          h = hom(y,x).qPolynomial()
          hom_zeros = [c for c in h.coefficients() if c[1] == 0 and c[0] != 0]
          return len(hom_zeros) >= 1
      
      def exists_destabilizing_sub_map(y,x):
          px, py = obj_to_phase(x, cc), obj_to_phase(y, cc)
          return (py > px) and (exists_hom_zero(y, x))

      for x in heart_by_length:
          if not any([exists_destabilizing_sub_map(y, x) for y in known_stables]):
              known_stables.append(x)
      return sorted(known_stables, key=lambda x: obj_to_phase(x, cc))
#+end_src

Helper function to plot a central charge.
#+begin_src sage :results silent
  def plot_cc(cc):
      positive_ccs = [vector(x) for x in root_matrix * vector(cc.values())]
      positive_roots_short = [short_name_root(x) for x in positives]
      return sum([plot(x) + text(y, 1.1*x) for (x,y) in zip(positive_ccs, positive_roots_short)])
#+end_src

Let us input a sample central charge.
  #+begin_src sage :results file
    # Both of these appear to be "type 1".
    cc1 = {1: -1 + I, 2: 20 + I, 3: -1 + 2*I, 4: -1 + 3*I}
    cc2 = {1: -1 + I, 2: 20 + I, 3: -1 + 2*I, 4: 9+3*I}

    # This one is "type 2".
    cc3 = {1: -1 + I, 2: 20 + I, 3: -1 + 5*I, 4: 9+3*I}

    # This one is "type 3".
    cc4 = {1: -1 + 10*I, 2: 20 + I, 3: -1 + 5*I, 4: 9+3*I}            
    cc = cc4
    plot_cc(cc)
  #+end_src

* Convex and reflex morphisms
A helper function to list all the homs between stables as well as their phases.
This is in order to discover the convex and reflex morphisms with factorings.
#+begin_src sage :results silent
  def homs_with_phases(stab, cc):
      homs_phases_list = []
      for i in range(0, len(stab)):
          for j in range(0, len(stab)):
              xi,xj = stab[i], stab[j]
              p = obj_to_phase(xj, cc) - obj_to_phase(xi, cc)
              hij = hom(xi,xj)
              hij.minimize()
              hij_degrees = sum([[k - l._grade for l in hij.objects(k)] for k in range(hij.minIndex(), hij.maxIndex()+1)], [])
              new_homs_phases = [(xi,xj,p + d) for d in hij_degrees]
              homs_phases_list = homs_phases_list + new_homs_phases
      return homs_phases_list      
#+end_src

Helper function to check if a graph has the "no-convex-factoring" property.
#+begin_src sage :results silent
  def no_convex_factoring_property(G):
      reflex_edges = [e for e in G.edges() if e[2] > 1]

      for e in reflex_edges:
          start, end, weight = e[0], e[1], e[2]
          for p in G.all_paths_iterator([start], [end], max_length = 3, report_edges=True, labels=True):
              if len(p) == 1:
                  # Path too short
                  continue
              if not all([f[2] < 1 for f in p]):
                  # The path is not totally convex.
                  continue
              if not abs(sum([f[2] for f in p]) - weight) < 0.0001:
                  # Weights don't sum to our weight.
                  continue
              else:
                  return False
      return True      
#+end_src

Helper function to check if a graph has the property that it has no minimal reflex cycles.
#+begin_src sage :results silent
  def no_min_reflex_cycles(G):
      reflex_edges = [e for e in G.edges() if e[2] > 1]
      min_reflex_edges = []

      for e in reflex_edges:
          # Check if e is non-minimal.
          start, end, weight = e[0], e[1], e[2]
          e_is_minimal_reflex = True
          for p in G.all_paths_iterator([start], [end], max_length = 3, report_edges=True, labels=True):
              # If the edge e has a convex/reflex factoring, then a factoring of length 2 is a witness to it.
              if len(p) == 1:
                  # Path too short
                  continue
              if not any([f[2] > 1 for f in p]):
                  # The path does not have a reflex morphism along it
                  continue
              if not abs(sum([f[2] for f in p]) - weight) < 0.0001:
                  # Weights don't sum to our weight
                  continue
              else:
                  e_is_minimal_reflex = False
                  break
              
          # If e is minimal reflex, add it to our list.
          if e_is_minimal_reflex:
              min_reflex_edges.append(e)

      #Build a graph on the minimal reflex edges only.
      G1 = DiGraph(min_reflex_edges)
      return G1.is_directed_acyclic()
#+end_src

#+begin_src sage :results silent
  def get_ncfs_and_nmrc(stab, cc):
      hwp = homs_with_phases(stab, cc)
      hwp_edges = [(short_name(x[0]), short_name(x[1]), x[2]) for x in hwp if x[0] != x[1]]
      G = DiGraph(hwp_edges)
      size6_subgraphs = [G.subgraph(x) for x in itertools.combinations(G.vertices(), 6)]
      print("Checking ncfs.")
      ncfs_6 = [set(H.vertices()) for H in size6_subgraphs if no_convex_factoring_property(H)]
      print("Checking nmrc.")
      nmrc_6 = [set(H.vertices()) for H in size6_subgraphs if no_min_reflex_cycles(H)]
      return G, ncfs_6, nmrc_6
#+end_src

Construct the flip graph of a set of proposed states.
#+begin_src sage :results silent
  def flip_graph(states):
      edges = [(frozenset(x),frozenset(y)) for x in states for y in states if len(x&y) == len(x) - 1]
      return Graph(edges)
#+end_src

* Expansive motions business
Write down a matrix of coefficients of simple roots for each positive root of the root system.
#+begin_src sage :results silent
  root_matrix = matrix([[r.coefficient(i) for i in indices] for r in positives])
#+end_src

Create variables to represent coordinates for the velocity vectors of the simple roots.
#+begin_src sage :results silent
  simple_velocities = matrix([[var('a' + str(i)), var('b' + str(i))] for i in indices])
#+end_src

Initialise a particular central charge. At the moment we are making up some "good" numbers.
WARNING: this part of the code is particular to type \(D_4\)!
#+begin_src sage :results silent
  #simple_ccs_d4 = matrix([vector([-2,1]), vector([20,1]), vector([-2,2]), vector([-1,2])])
#+end_src

Now compute the central charges and (indeterminate) velocities for all the positive roots.
#+begin_src sage :results silent
  positive_ccs = [vector(x) for x in root_matrix * vector(cc.values())]
  #positive_ccs = root_matrix * simple_ccs_d4
  positive_velocities = root_matrix * simple_velocities
#+end_src

** Expansive inequalities and polytope of expansive motions
The various inequalities are of the form \(\langle z, v \rangle \ge 0\), where \(z\) is a central charge vector and \(v\) is the corresponding velocity vector.
We create a list of inequalities (in a form acceptable to sage), and then construct a polyhedron defined by these inequalities over \(\mathbb{Q}\).
#+begin_src sage :results silent
  def eq_to_ieq(expr):
       return [0] + [expr.coefficient(x) for x in simple_velocities.list()]

  ineqs = [eq_to_ieq(x.dot_product(y)) for (x,y) in zip(positive_velocities, positive_ccs)]

  P = Polyhedron(ieqs = ineqs, base_ring=QQ)
#+end_src

** Computations on extremal rays
Recall that an extremal ray consists of the \(x\) and \(y\) coordinates for each of the velocity vectors.
The following function converts an extremal ray into a matrix of velocities, by splitting the list into pieces of size \(2\) and then converting the output into a matrix.
#+begin_src sage :results silent
  def ray_to_velocity_matrix(r):
      return matrix([r[i:i+2] for i in range(0,len(r),2)])
#+end_src

A matrix of velocities corresponding to an extremal ray specifies how each point moves so that we get an infinitesimally expansive motion.
The central charge vectors that remain rigid (do not expand) are exactly the ones whose velocity vector have zero dot product with the corresponding central charge vector.
The collection of these central charge vectors forms (the closure of) a state, namely the appropriate analogue of a pointed pseudo-triangulation without an external edge.
Among these, some subcollections form rigid components: these are distinguished by the fact that they all have the same ratio of the length of the velocity vector to the length of the central charge vector.

The following function produces a list of rigid components given an extremal ray.
#+begin_src sage :results silent
  def rigid_components(ray):
      velocities = root_matrix * ray_to_velocity_matrix(ray)
      rigid_roots_ratios = [(ray,x.norm()/y.norm())
                            for (ray,x,y) in zip(positives,velocities, positive_ccs) if x.dot_product(y) == 0]
      unique_ratios = set(t[1] for t in rigid_roots_ratios)
      components = []
      for ratio in unique_ratios:
          this_component = []
          for t in rigid_roots_ratios:
              if t[1] == ratio:
                  this_component.append(t[0])
          components.append(this_component)

      return components
#+end_src

** Results
First we draw the stability condition we have constructed.
#+begin_src sage :results file :exports both
  sum([plot(x) + text(y, x + vector([0,0.5]))
       for (x,y) in zip(positive_ccs, positives)])
#+end_src

#+RESULTS:
[[file:/tmp/tmpjexuzurg/tmp_4q86gr7g.png]]

Next we compute the rigid components for each of the extremal rays of the polyhedron \(P\).
#+begin_src sage :exports both :results silent
  collapsed_components = [rigid_components(r) for r in P.ray_generator()]
  collapsed_states = [flatten(x) for x in collapsed_components]
  collapsed_states = [set([short_name_root(x) for x in s]) for s in collapsed_states]
#+end_src

Let us try to tease out the "real" states from the collapsed states.
We start with the list of 6-element collapsed states: these are certainly real.
Make them all sets for ease of comparison and intersections.
#+begin_src sage :results silent
  original_states = set([frozenset(x) for x in collapsed_states if len(x) == 6])
#+end_src

Now consider all collapsed states, and look at all potential 6-element subsets of them.
#+begin_src sage :results silent
  potential_states = set(sum([[frozenset(x) for x in itertools.combinations(s,6)] for s in collapsed_states], []))
#+end_src

#+begin_src sage :results silent
  def flips(state, potential_states):
      for x in state:
          sub_state = state - set([x])
          flips = [s for s in potential_states if sub_state & s == sub_state]
          print(flips)
#+end_src
