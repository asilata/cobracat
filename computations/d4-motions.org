# Last updated: [2022-03-28 Mon]
#+property: header-args:sage :session foo

* Basic setup for D4

Basic setup for D4
#+begin_src sage
  load("d4-setup.sage")
#+end_src

#+RESULTS:
: Defining e_1, e_2, e_3, e_4, a, b, c, d, e, f, fa, db, ec, af

HN filtrations
#+begin_src sage 
  load("../HN.sage")
#+end_src

#+RESULTS:

* A stability condition 

A particular stability condition (P1, P2, P3) are on the left and P4 is far to the right and long.

#+begin_src sage :results silent
    simple_root_labels_d4 = ['1', '2', '3', 'x']
    simple_roots_d4 = vector([var('r' + l) for l in simple_root_labels_d4])
#+end_src
  
The actual stability condition
#+begin_src sage :results silent
    stab = [P4, s1(P4), s3(P4), s2(P4), internalTwist(t4(t1(t2(t3(P4)))),-2).shift(2), s1(s3(P4)), s1(s2(P4)), s1(s3(P4)), s1(s2(s3(P4))), P3, P2, P1]
    stabclasses = [rx, r1+rx, r3+rx, r2+rx, r3+r2+r1+2*rx, r1+r3+rx, r1+r2+rx, r1+r3+rx, r1+r2+r3+rx, r3, r2, r1]
#+end_src

* A weird example
This is a possible example of a spherical object whose support does not admit an expansive motion.
But it's not. 
It just means that the "resolution" of the expansive motions into 6 element states was incorrect.

An object
#+begin_src sage :session foo
  X = s1(t4(t3(t2(t4(P1)))))
  HN(X,stab)
#+end_src

#+RESULTS:
: <string>:136: DeprecationWarning: the output of uniq(X) being sorted is deprecated; use sorted(set(X)) instead if you want sorted output
: See https://trac.sagemath.org/27014 for details.
: <string>:40: DeprecationWarning: the output of uniq(X) being sorted is deprecated; use sorted(set(X)) instead if you want sorted output
: See https://trac.sagemath.org/27014 for details.
: [[2]: P1<2>+P2<2>+P3<2> → P4<3> :[3],
:  [0]: P1<0> → P4<1> :[1],
:  [-1]: P1<-2> :[-1]]

* More HN filtrations
States admitting expansive motions.
#+begin_src sage
  collapsed_states = [[r1, r3, rx, r1 + rx, r3 + rx, r1 + r3 + rx, r2 + rx],
                      [r1, r2, r3 + rx, r1 + r3 + rx, r2 + r3 + rx, r1 + r2 + r3 + rx, r3],
                      [r1,
                       r2,
                       r3 + rx,
                       r1 + r3 + rx,
                       r2 + r3 + rx,
                       r1 + r2 + r3 + rx,
                       r1 + r2 + rx],
                      [r2,
                       r3,
                       r1 + rx,
                       r1 + r2 + rx,
                       r1 + r3 + rx,
                       r1 + r2 + r3 + rx,
                       r2 + r3 + rx],
                      [r1,
                       r2 + rx,
                       r3 + rx,
                       r1 + r2 + rx,
                       r1 + r3 + rx,
                       r1 + r2 + r3 + 2*rx,
                       r2 + r3 + rx],
                      [r2, r3, r1 + rx, r1 + r2 + rx, r1 + r3 + rx, r1 + r2 + r3 + rx, r1],
                      [r2, r1, r3, rx, r1 + rx, r3 + rx, r1 + r3 + rx],
                      [r3 + rx,
                       r3,
                       r1 + rx,
                       r2 + rx,
                       r1 + r3 + rx,
                       r2 + r3 + rx,
                       r1 + r2 + r3 + 2*rx],
                      [r1 + r2 + rx,
                       r3,
                       r1 + rx,
                       r2 + rx,
                       r1 + r3 + rx,
                       r2 + r3 + rx,
                       r1 + r2 + r3 + 2*rx],
                      [r1 + rx,
                       r1,
                       r2 + rx,
                       r3 + rx,
                       r1 + r2 + rx,
                       r1 + r3 + rx,
                       r1 + r2 + r3 + 2*rx],
                      [r2, r1, r3, r2 + rx, r1 + r2 + rx, r2 + r3 + rx, r1 + r2 + r3 + rx],
                      [r2, r1 + rx, r1 + r2 + rx, r3, r2 + rx, r2 + r3 + rx],
                      [r2, r3, rx, r2 + rx, r3 + rx, r2 + r3 + rx, r1],
                      [r2, r3 + rx, r2 + r3 + rx, r1, r2 + rx, r1 + r2 + rx],
                      [r1, r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3 + rx],
                      [r2, r3, rx, r2 + rx, r3 + rx, r2 + r3 + rx, r1 + rx],
                      [r1, r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3],
                      [r2,
                       r1 + rx,
                       r3 + rx,
                       r1 + r2 + rx,
                       r2 + r3 + rx,
                       r1 + r2 + r3 + 2*rx,
                       r2 + rx],
                      [r2,
                       r1 + rx,
                       r3 + rx,
                       r1 + r2 + rx,
                       r2 + r3 + rx,
                       r1 + r2 + r3 + 2*rx,
                       r1 + r3 + rx],
                      [r3, r1 + rx, r1 + r3 + rx, r1, r2 + rx, r1 + r2 + rx],
                      [r2, r3 + rx, r2 + r3 + rx, r3, r1 + rx, r1 + r3 + rx],
                      [r2, r1 + rx, r1 + r2 + rx, r1, r3 + rx, r1 + r3 + rx],
                      [r1, r3 + rx, r1 + r3 + rx, r3, r2 + rx, r2 + r3 + rx],
                      [r1,
                       r3,
                       r2 + rx,
                       r1 + r2 + rx,
                       r2 + r3 + rx,
                       r1 + r2 + r3 + rx,
                       r1 + r3 + rx]]
#+end_src

#+RESULTS:

Testing various objects
#+begin_src sage
  s123x = composeAll([s1, s2, s3, s4, t3, t2, t1])
  t123x = composeAll([s1, s2, s3, t4, t3, t2, t1])
  s123xx = composeAll([t4, t1, t2, t3, s4, s3, t2, t1, t4])
  t123xx = composeAll([t4, t1, t2, t3, t4, s3, t2, t1, t4])
  X = s123xx(stab[4])
  supp = support(X, stab)
  print([stabclasses[i] for i in supp])
  states = [s for s in collapsed_states if all([stabclasses[i] in s for i in supp])]
  print(states)
  len(states)
#+end_src
#+RESULTS:
: <string>:40: DeprecationWarning: the output of uniq(X) being sorted is deprecated; use sorted(set(X)) instead if you want sorted output
: See https://trac.sagemath.org/27014 for details.
: [r1 + rx, r3 + rx, r2 + rx, r1 + r2 + r3 + 2*rx, r1 + r2 + rx]
: [[r1 + rx, r1, r2 + rx, r3 + rx, r1 + r2 + rx, r1 + r3 + rx, r1 + r2 + r3 + 2*rx], [r2, r1 + rx, r3 + rx, r1 + r2 + rx, r2 + r3 + rx, r1 + r2 + r3 + 2*rx, r2 + rx]]
: 2

#+begin_src sage
  Y = s4(s1(s4(t3(t4(t2(t2(t4(P1))))))))
  supp = support(Y, stab)
  print([stabclasses[i] for i in supp])
  states = [s for s in collapsed_states if all([stabclasses[i] in s for i in supp])]
  print(states)
  len(states)
#+end_src

#+RESULTS:
: <string>:40: DeprecationWarning: the output of uniq(X) being sorted is deprecated; use sorted(set(X)) instead if you want sorted output
: See https://trac.sagemath.org/27014 for details.
: [rx, r1 + rx, r1 + r2 + rx, r3, r2, r1]
: [[r1, r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3]]
: 1

So the following state is real.
#+RESULTS:
: <string>:40: DeprecationWarning: the output of uniq(X) being sorted is deprecated; use sorted(set(X)) instead if you want sorted output
: See https://trac.sagemath.org/27014 for details.
: [rx, r1 + rx, r1 + r2 + rx, r3, r2, r1]
: [[r1, r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3]]
: 1

#+begin_src sage
  Y = s4(s1(s4(t3(t4(t2(t2(t4(P3))))))))
  supp = support(Y, stab)
  print([stabclasses[i] for i in supp])
  states = [s for s in collapsed_states if all([stabclasses[i] in s for i in supp])]
  print(states)
  len(states)
#+end_src

So the following state is real.
#+RESULTS:
: <string>:40: DeprecationWarning: the output of uniq(X) being sorted is deprecated; use sorted(set(X)) instead if you want sorted output
: See https://trac.sagemath.org/27014 for details.
: [rx, r1 + rx, r1 + r2 + rx, r3, r2, r1]
: [[r1, r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3]]
: 1

#+begin_src sage 
  Y = s3(s4(s1(s4(t3(t4(t2(t2(t4(P1)))))))))
  supp = support(Y, stab)
  states = [s for s in collapsed_states if all([stabclasses[i] in s for i in supp])]
  [stabclasses[i] for i in support(Y, stab)]
#+end_src

#+RESULTS:
: <string>:40: DeprecationWarning: the output of uniq(X) being sorted is deprecated; use sorted(set(X)) instead if you want sorted output
: See https://trac.sagemath.org/27014 for details.
: [r1 + rx, r3 + rx, r1 + r3 + rx, r1 + r2 + rx, r2, r1]

Thanks to the object above and symmetry, all the states below are real.
#+begin_src sage
  [s for s in collapsed_states if len(s) == 6]
#+end_src

#+RESULTS:
: [[r2, r1 + rx, r1 + r2 + rx, r3, r2 + rx, r2 + r3 + rx],
:  [r2, r3 + rx, r2 + r3 + rx, r1, r2 + rx, r1 + r2 + rx],
:  [r3, r1 + rx, r1 + r3 + rx, r1, r2 + rx, r1 + r2 + rx],
:  [r2, r3 + rx, r2 + r3 + rx, r3, r1 + rx, r1 + r3 + rx],
:  [r2, r1 + rx, r1 + r2 + rx, r1, r3 + rx, r1 + r3 + rx],
:  [r1, r3 + rx, r1 + r3 + rx, r3, r2 + rx, r2 + r3 + rx]]

Let us take [rx, r1 + rx, r1 + r2 + rx, r3, r2, r1] and delete P1.
#+begin_src  sage
  [s for s in collapsed_states if all([x in s for x in [rx, r1 + rx, r1 + r2 + rx, r3, r2]])]
#+end_src

#+RESULTS:
: [[r1, r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3]]

This implies that the following state must be real:
# [r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3]

Note that this state is 1 flip away from one of the original 6 element states.

Let us take [rx, r1 + rx, r1 + r2 + rx, r3, r2, r2 + rx] and delete P2.
#+begin_src  sage
  [s for s in collapsed_states if all([x in s for x in [rx, r1 + rx, r1 + r2 + rx, r3, r2+rx]])]
#+end_src

#+RESULTS:
: [[r1, r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3]]

This implies that the following state must be real.
# [[[r1, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3]]]

Let us take [rx, r1 + rx, r1 + r2 + rx, r3, r2, r2 + rx] and delete P1 -> Px
#+begin_src  sage
  [s for s in collapsed_states if all([x in s for x in [rx, r1 + rx, r1 + r2 + rx, r3, r2, r2 + rx]])]
#+end_src

#+RESULTS:
: [[r1, r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3]]

So the following must be real.
# [[[r1, r2, rx, r2 + rx, r1 + r2 + rx, r3]]]

Let us take [rx, r1 + rx, r1 + r2 + rx, r3, r2, r2 + rx] and delete P3
#+begin_src  sage
  [s for s in collapsed_states if all([x in s for x in [rx, r1 + rx, r1 + r2 + rx, r2, r2 + rx]])]
#+end_src

#+RESULTS:
: [[r1, r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3 + rx],
:  [r1, r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3]]
This gives two possibilities, but one is suspicious.  So we believe the following is real.
# [r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3 + rx]

Let us take [rx, r1 + rx, r1 + r2 + rx, r3, r2, r2 + rx] and delete P1, P2 -> Px
#+begin_src  sage
  [s for s in collapsed_states if all([x in s for x in [rx, r1 + rx, r3, r2, r2 + rx]])]
#+end_src

#+RESULTS:
: [[r2, r3, rx, r2 + rx, r3 + rx, r2 + r3 + rx, r1 + rx],
:  [r1, r2, rx, r1 + rx, r2 + rx, r1 + r2 + rx, r3]]
This give two possibilities, but one is suspicious.  So we believe the following is real.
# [r2, r3, rx, r2 + rx, r2 + r3 + rx, r1 + rx]

** Associated pictures from the board
*** Conjectural flip picture:
#+DOWNLOADED: screenshot @ 2022-03-30 14:45:04
[[file:assets/More_HN_filtrations/2022-03-30_14-45-04_screenshot.png]]
*** Stable objects colored

#+DOWNLOADED: screenshot @ 2022-03-30 14:47:33
[[file:assets/More_HN_filtrations/2022-03-30_14-47-33_screenshot.png]]
* All  the states in a particular stability condition.
#+begin_src sage
  central_charge = matrix([[-3,1],[-2,1], [-1,1],[7,0]])
  central_charge_euclidean = change_of_basis.inverse() * central_charge
#+end_src

#+RESULTS:

Notation:
X1 = P1
X2 = P2
X3 = P3
Y1 = P2, P3 -> Px
Y2 = P1, P3 -> Px
Y3 = P1, P2 -> Px
Z1 = P1->Px
Z2 = P2->Px
Z3 = P3->Px
A = P1, P2, P3 -> Px,Px
B = Px
C = P1, P2, P3 -> Px

#+begin_src sage :results none
  objects = var('X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3', 'Z1', 'Z2', 'Z3', 'A', 'B', 'C')
  Xs = {1:X1, 2:X2, 3:X3}
  Ys = {1:Y1, 2:Y2, 3:Y3}
  Zs = {1:Z1, 2:Z2, 3:Z3}
#+end_src

Type 1
#+begin_src sage
  type1_states =[
        [Xs[p(1)], Xs[p(2)], Ys[p(1)], Ys[p(3)], Zs[p(2)], Zs[p(3)]]
        for p in SymmetricGroup(3)
    ]
  type1_states
#+end_src

#+RESULTS:
: [[X1, X2, Y1, Y3, Z2, Z3],
:  [X3, X1, Y3, Y2, Z1, Z2],
:  [X2, X3, Y2, Y1, Z3, Z1],
:  [X1, X3, Y1, Y2, Z3, Z2],
:  [X3, X2, Y3, Y1, Z2, Z1],
:  [X2, X1, Y2, Y3, Z1, Z3]]

Type 2
#+begin_src sage
  type2_states = [[B, Xs[p(1)], Xs[p(2)], Zs[p(2)], Zs[p(3)], Ys[p(1)]]     for p in SymmetricGroup(3)] +  [[B, Xs[p(1)], Xs[p(2)], Zs[p(2)], Zs[p(3)], Ys[p(3)]]     for p in SymmetricGroup(3)] +  [[C, Ys[p(1)], Ys[p(2)], Xs[p(2)], Xs[p(3)], Zs[p(1)]]     for p in SymmetricGroup(3)] +  [[C, Ys[p(1)], Ys[p(2)], Xs[p(2)], Xs[p(3)], Zs[p(3)]]     for p in SymmetricGroup(3)] +  [[A, Zs[p(1)], Zs[p(2)], Ys[p(2)], Ys[p(3)], Xs[p(1)]]     for p in SymmetricGroup(3)] +  [[A, Zs[p(1)], Zs[p(2)], Ys[p(2)], Ys[p(3)], Xs[p(3)]]     for p in SymmetricGroup(3)]
  type2_states
#+end_src

#+RESULTS:
#+begin_example
[[B, X1, X2, Z2, Z3, Y1],
 [B, X3, X1, Z1, Z2, Y3],
 [B, X2, X3, Z3, Z1, Y2],
 [B, X1, X3, Z3, Z2, Y1],
 [B, X3, X2, Z2, Z1, Y3],
 [B, X2, X1, Z1, Z3, Y2],
 [B, X1, X2, Z2, Z3, Y3],
 [B, X3, X1, Z1, Z2, Y2],
 [B, X2, X3, Z3, Z1, Y1],
 [B, X1, X3, Z3, Z2, Y2],
 [B, X3, X2, Z2, Z1, Y1],
 [B, X2, X1, Z1, Z3, Y3],
 [C, Y1, Y2, X2, X3, Z1],
 [C, Y3, Y1, X1, X2, Z3],
 [C, Y2, Y3, X3, X1, Z2],
 [C, Y1, Y3, X3, X2, Z1],
 [C, Y3, Y2, X2, X1, Z3],
 [C, Y2, Y1, X1, X3, Z2],
 [C, Y1, Y2, X2, X3, Z3],
 [C, Y3, Y1, X1, X2, Z2],
 [C, Y2, Y3, X3, X1, Z1],
 [C, Y1, Y3, X3, X2, Z2],
 [C, Y3, Y2, X2, X1, Z1],
 [C, Y2, Y1, X1, X3, Z3],
 [A, Z1, Z2, Y2, Y3, X1],
 [A, Z3, Z1, Y1, Y2, X3],
 [A, Z2, Z3, Y3, Y1, X2],
 [A, Z1, Z3, Y3, Y2, X1],
 [A, Z3, Z2, Y2, Y1, X3],
 [A, Z2, Z1, Y1, Y3, X2],
 [A, Z1, Z2, Y2, Y3, X3],
 [A, Z3, Z1, Y1, Y2, X2],
 [A, Z2, Z3, Y3, Y1, X1],
 [A, Z1, Z3, Y3, Y2, X2],
 [A, Z3, Z2, Y2, Y1, X1],
 [A, Z2, Z1, Y1, Y3, X3]]
#+end_example

Type 3
#+begin_src sage
  type3_states = [[B, Xs[1], Xs[2], Xs[3], Zs[p(1)], Ys[p(2)]] for p in SymmetricGroup(3)]   +  [[B, Zs[1], Zs[2], Zs[3], Xs[p(1)], Ys[p(2)]] for p in SymmetricGroup(3)]+  [[C, Ys[1], Ys[2], Ys[3], Xs[p(1)], Zs[p(2)]] for p in SymmetricGroup(3)]  +  [[C, Xs[1], Xs[2], Xs[3], Ys[p(1)], Zs[p(2)]] for p in SymmetricGroup(3)]+  [[A, Zs[1], Zs[2], Zs[3], Ys[p(1)], Xs[p(2)]] for p in SymmetricGroup(3)]  +  [[A, Ys[1], Ys[2], Ys[3], Zs[p(1)], Xs[p(2)]] for p in SymmetricGroup(3)]
  type3_states
#+end_src

#+RESULTS:
#+begin_example
[[B, X1, X2, X3, Z1, Y2],
 [B, X1, X2, X3, Z3, Y1],
 [B, X1, X2, X3, Z2, Y3],
 [B, X1, X2, X3, Z1, Y3],
 [B, X1, X2, X3, Z3, Y2],
 [B, X1, X2, X3, Z2, Y1],
 [B, Z1, Z2, Z3, X1, Y2],
 [B, Z1, Z2, Z3, X3, Y1],
 [B, Z1, Z2, Z3, X2, Y3],
 [B, Z1, Z2, Z3, X1, Y3],
 [B, Z1, Z2, Z3, X3, Y2],
 [B, Z1, Z2, Z3, X2, Y1],
 [C, Y1, Y2, Y3, X1, Z2],
 [C, Y1, Y2, Y3, X3, Z1],
 [C, Y1, Y2, Y3, X2, Z3],
 [C, Y1, Y2, Y3, X1, Z3],
 [C, Y1, Y2, Y3, X3, Z2],
 [C, Y1, Y2, Y3, X2, Z1],
 [C, X1, X2, X3, Y1, Z2],
 [C, X1, X2, X3, Y3, Z1],
 [C, X1, X2, X3, Y2, Z3],
 [C, X1, X2, X3, Y1, Z3],
 [C, X1, X2, X3, Y3, Z2],
 [C, X1, X2, X3, Y2, Z1],
 [A, Z1, Z2, Z3, Y1, X2],
 [A, Z1, Z2, Z3, Y3, X1],
 [A, Z1, Z2, Z3, Y2, X3],
 [A, Z1, Z2, Z3, Y1, X3],
 [A, Z1, Z2, Z3, Y3, X2],
 [A, Z1, Z2, Z3, Y2, X1],
 [A, Y1, Y2, Y3, Z1, X2],
 [A, Y1, Y2, Y3, Z3, X1],
 [A, Y1, Y2, Y3, Z2, X3],
 [A, Y1, Y2, Y3, Z1, X3],
 [A, Y1, Y2, Y3, Z3, X2],
 [A, Y1, Y2, Y3, Z2, X1]]
#+end_example

#+begin_src sage
  states = type1_states + type2_states + type3_states
#+end_src

#+RESULTS:

All simplices
#+begin_src sage
  def simplicies(i):
      return [x for x in Set(objects).subsets(i) if any([set(x).issubset(set(s)) for s in states])]
  [len(simplicies(i)) for i in range(1,7)]
 #+end_src

 #+RESULTS:
 : [12, 63, 180, 285, 234, 78]
#+begin_src sage
  12 - 63 + 180 - 285 + 234 - 78
#+end_src

#+RESULTS:
: 0

** Checking pair/triple/quadruple

Is it a pairwise condition?  Almost but not quite
#+begin_src sage
  forbidden2 = [x for x in Set(objects).subsets(2) if Set(x) not in simplicies(2)]
  [y for y in [x for x in Set(objects).subsets(3) if all([not f.issubset(x) for f in forbidden2])] if y not in simplicies(3)]
#+end_src

#+RESULTS:
#+begin_example
[{Y3, Y2, B},
 {Y3, B, Y1},
 {Y3, X3, Z3},
 {Y2, B, Y1},
 {Y2, X2, Z2},
 {A, X2, X1},
 {X3, A, X2},
 {C, Z3, Z2},
 {Z1, C, Z3},
 {X3, A, X1},
 {Z1, Y1, X1},
 {Z1, C, Z2}]
#+end_example

Is it a pair and triple condition?  No!
#+begin_src sage
  forbidden2 = [x for x in Set(objects).subsets(2) if Set(x) not in simplicies(2)]
  forbidden3 = [x for x in Set(objects).subsets(3) if Set(x) not in simplicies(3)]
  [y for y in [x for x in Set(objects).subsets(4) if all([not f.issubset(x) for f in forbidden2 + forbidden3])] if y not in simplicies(4)]
#+end_src

#+RESULTS:
: [{X2, X1, Z2, Z1},
:  {Y1, X3, X1, Y3},
:  {Y1, X2, X1, Y2},
:  {Z3, X3, X1, Z1},
:  {Y1, Z2, Z1, Y2},
:  {X3, X2, Z3, Z2},
:  {Z3, Z2, Y3, Y2},
:  {Y1, Z3, Z1, Y3},
:  {X3, X2, Y3, Y2}]

Is it a pair and triple and quadruple condition?  
#+begin_src sage
  forbidden2 = [x for x in Set(objects).subsets(2) if Set(x) not in simplicies(2)]
  forbidden3 = [x for x in Set(objects).subsets(3) if Set(x) not in simplicies(3)]
  forbidden4 = [x for x in Set(objects).subsets(4) if Set(x) not in simplicies(4)]
  len([y for y in [x for x in Set(objects).subsets(5) if all([not f.issubset(x) for f in forbidden2 + forbidden3 + forbidden4])]])
#+end_src

#+RESULTS:
: 234
** The polytope of all the states
Sage allows us to build a simplicial complex.
#+begin_src sage
  sphericals = SimplicialComplex(states)
  vertices = sphericals.vertices()
  sphericals.connected_component(vertices[1])
#+end_src

#+RESULTS:

Let us compute the (reduced) homology.
#+begin_src sage
  sphericals.homology()
#+end_src

#+RESULTS:
: {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: Z}

#+begin_src sage
  sphericals.is_connected()
sphericals.connected_component()
#+end_src

#+RESULTS:
: False
: Simplicial complex with vertex set () and facets {()}


#+begin_src sage
  sphericals.is_pseudomanifold()
#+end_src

#+RESULTS:
: True

#+begin_src sage
  sphericals.fundamental_group()
#+end_src

#+RESULTS:
** Visualizing a state
We first draw the central charge.
#+begin_src  sage :results file
  central_charge_plot = sum([point(central_charge_euclidean.rows()[i], color='blue', size=100) for i in range(0,4)]) + sum([point(-1*central_charge_euclidean.rows()[i], color='red', size=100) for i in range(0,4)]) + point((0,0), color='black', size=100)
  central_charge_plot
#+end_src

#+RESULTS:
[[file:/home/anandrd/.sage/temp/proteus/431515/tmp_7do4o88h.png]]

We now plot states.  We first record the classes of the objects.
#+begin_src  sage
      alpha = R.root_lattice().simple_roots()
      classes = {
          X1 : alpha[1],
          X2 : alpha[2],
          X3 : alpha[3],
          Y1 : alpha[2]+ alpha[3] + alpha[4],
          Y2 : alpha[1]+ alpha[3] + alpha[4],
          Y3 : alpha[1]+ alpha[2] + alpha[4],
          Z1 : alpha[1]+alpha[4],
          Z2 : alpha[2]+alpha[4],
          Z3 : alpha[3]+alpha[4],
          A : alpha[1]+ alpha[2]+ alpha[3] + alpha[4]+alpha[4],
          B : alpha[4],
          C : alpha[1]+ alpha[2]+ alpha[3] + alpha[4]
      }
      ambient_basis =   R.ambient_space().basis()
      def root_as_difference(root):
          return [((s,i),(t,j)) for i in range(0,4) for j in range(0,4) for s in [1,-1] for t in [1,-1] if s*vector(ambient_basis[i]) - t*vector(ambient_basis[j]) == vector(R.ambient_space()(root))]
  
      roots_as_differences = {r : root_as_difference(r) for r in classes.values()}
  #+end_src

  #+RESULTS:

  
  We now plot an object.
  #+begin_src sage :results file
    ambient_basis =   R.ambient_space().basis()
    def plot_object(x, color='blue'):
            xclass = classes[x]
            return sum([arrow(t * vector(ambient_basis[j]) * central_charge_euclidean, s * vector(ambient_basis[i]) * central_charge_euclidean, color=color, width=1,arrowsize=5) for ((s,i), (t,j)) in roots_as_differences[xclass]])
    
    def plot_state(state):
            return sum([plot_object(x, color=r) for (x,r) in zip(state, rainbow(6))])
    
    
    (plot_state(states[0]) + central_charge_plot).show(axes=False)
#+end_src

#+RESULTS:
[[file:/home/anandrd/.sage/temp/proteus/431515/tmp_2wid_yd5.png]]

** Expansive motion of a state
#+begin_src sage 
  def expansive_motion(state):
      vvars = var('v01','v02','v11','v12','v21','v22','v31', 'v32')
      positive_roots = R.root_lattice().positive_roots()
      V = matrix([[v01,v02],[v11,v12],[v21,v22],[v31,v32]])
      equations = []
      inequations = []
      for r in positive_roots:
          ramb = vector(R.ambient_space()(r))
          v = (ramb*V).dot_product(ramb*central_charge_euclidean)
          inequations.append(vector([0]+[v.coefficient(variable) for variable in vvars]))
  
      for x in state:
           r = classes[x]
           ramb = vector(R.ambient_space()(r))
           v = (ramb*V).dot_product(ramb*central_charge_euclidean)
           equations.append(vector([0]+[v.coefficient(variable) for variable in vvars]))
  
      P = Polyhedron(ieqs = [vector(QQ, v) for v in inequations] + [vector(QQ, v) for v in equations] + [-1*vector(QQ, v) for v in equations])
      return P
  
  def plot_motion(V):
      rays = []
      for i in range(0,4):
          base = vector(ambient_basis[i]) * central_charge_euclidean
          direction = vector(ambient_basis[i]) * V
          rays.append(arrow(base, base+direction, width=0.5, arrowsize=2, linestyle='dotted'))
          base = -vector(ambient_basis[i]) * central_charge_euclidean
          direction = -vector(ambient_basis[i]) * V
          rays.append(arrow(base, base+direction, color='red', width=0.5, arrowsize=1, linestyle='dotted'))
      return sum(rays)
  #+end_src

** Pictures of all the states
#+begin_src sage
  i = 5
  P = expansive_motion(states[i])
  v = vector(P.rays()[0])/10 + 0.18 * vector(P.lines()[0])
  V = matrix([[v[0],v[1]],[v[2],v[3]],[v[4],v[5]],[v[6],v[7]]])
  [(plot_state(s) + central_charge_plot).show(aspect_ratio=1, axes=False) for s in states]
#+end_src

#+begin_src sage
  states[7]
#+end_src

#+RESULTS:
: [B, X3, X1, Z1, Z2, Y3]

#+begin_src sage :results file
  (plot_object(Y1) + central_charge_plot).show(axes=False, aspect_ratio=1)
#+end_src

#+RESULTS:
[[file:/home/anandrd/.sage/temp/proteus/431515/tmp__t2r0dmg.png]]

*** Observations
1. It is possible to have intersections between edges of the same kind. 
   See state[11], where both B and Y2 appear ([B, X2, X1, Z1, Z3, Y2]).
2. It is possible to have failure of pointedness.
   See state[1] = [X3, X1, Y3, Y2, Z1, Z2] where Y3, Z2, X3, Y2 create unpointedness at e4.
