#+PROPERTY: header-args:javascript :tangle artifacts/ttauta3.js :mkdirp yes
#+PROPERTY: header-args:html :tangle artifacts/ttauta3.html :mkdirp yes
#+PROPERTY: header-args:dot :tangle artifacts/ttauta3.dot :mkdirp yes

* Generation of supports 
** Convex
  The first kind of supports involve a "convex" stability condition, where the notation is a, b, c, d (clockwise) with diagonals x (triangle with ab) and y (triangle with bc). The symmetry group here is \(D_4\). Everything is in the orbit of "abcx".

** Concave
   The second kind of supports involve "concave" stability condition, where the notation is a, b, c for the outside edges and x, y, z for the inside edges with a-x disjoint, b-y disjoint, and c-z disjoint. Here, there are two types of supports: arrows and flags. The symmetry group is \(D_3\).
*** Arrows
    Everything is in the orbit of "abxy"
*** Flags
    Everything is in the orbit of "abyz"

* Massive simplification
  When we transform from one kind of stability condition to another, there is no "preferred" labelling. So why don't we always label the convex stability condition by "abcx" and the concave ones by "abxy" or "abyz"!


* The automaton table
  Notation for wall-crossings.
  For convex stability conditions, ab-x denotes the transformation where the intersection of a and b crosses x.
  For concave stability, o-c denotes the transformation where the interior vertex crosses c.
  
  | abcx | ab-x | a > b | abyz | a:b, b:c, y:a+x, z:x   |
  | abcx | ab-x | b > a | abyz | a:a, b:c, y:x, z:b+x   |
  | abcx | ad-y | ---   | abyz | a:b, b:c, y:a, z:x     |
  | abcx | cd-x | ---   | abxy | a:a, b:b, x:x+c, y:x   |
  | abcx | bc-y | b > c | abyz | a:a, b:c, y:x, z:b-c   |
  | abcx | bc-y | c > b | abxy | a:a, b:b, x:c-b, y:x   |
  | abyz | o-c  | ---   | abcx | a:y, b:a, c:b, x:z     |
  | abyz | o-b  | ---   | abcx | a:a, b:b+z, c:b, x:y   |
  | abyz | o-a  | z > y | abcx | a:a, b:a+z-y, c:b, x:y |
  | abyz | o-a  | y > z | abcx | a:a+y-z, b:a, c:b, x:z |
  | abxy | o-a  | ---   | abcx | a:b, b:a, c:a+y, x:x   |
  | abxy | o-b  | ---   | abcx | a:a, b:b, c:b+x, x:y   |
  | abxy | o-c  | x > y | abcx | a:a, b:b, c:x-y, x:y   |
  | abxy | o-c  | y > x | abcx | a:b, b:a, c:y-x, x:x   |
  

* The graph  
  #+begin_src dot 
    digraph ttauta3wc {
	"abcx" -> "abyz" [label="ab-x | a > b", tooltip="a:b, b:c, y:a+x, z:x   "];
	"abcx" -> "abyz" [label="ab-x | b > a", tooltip="a:a, b:c, y:x, z:b+x   "];
	"abcx" -> "abyz" [label="ad-y | ---  ", tooltip="a:b, b:c, y:a, z:x     "];
	"abcx" -> "abxy" [label="cd-x | ---  ", tooltip="a:a, b:b, x:x+c, y:x   "];
	"abcx" -> "abyz" [label="bc-y | b > c", tooltip="a:a, b:c, y:x, z:b-c   "];
	"abcx" -> "abxy" [label="bc-y | c > b", tooltip="a:a, b:b, x:c-b, y:x   "];
	"abyz" -> "abcx" [label="o-c  | ---  ", tooltip="a:y, b:a, c:b, x:z     "];
	"abyz" -> "abcx" [label="o-b  | ---  ", tooltip="a:a, b:b+z, c:b, x:y   "];
	"abyz" -> "abcx" [label="o-a  | z > y", tooltip="a:a, b:a+z-y, c:b, x:y "];
	"abyz" -> "abcx" [label="o-a  | y > z", tooltip="a:a+y-z, b:a, c:b, x:z "];
	"abxy" -> "abcx" [label="o-a  | ---  ", tooltip="a:b, b:a, c:a+y, x:x   "];
	"abxy" -> "abcx" [label="o-b  | ---  ", tooltip="a:a, b:b, c:b+x, x:y   "];
	"abxy" -> "abcx" [label="o-c  | x > y", tooltip="a:a, b:b, c:x-y, x:y   "];
	"abxy" -> "abcx" [label="o-c  | y > x", tooltip="a:b, b:a, c:y-x, x:x   "];
    }		
  #+end_src


* Helper functions  

  #+begin_src elisp
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((dot . t))) ; this line activates dot

    (defun rotate4 (x)
      (cond
       ((equal x ?a) ?b)
       ((equal x ?b) ?c)
       ((equal x ?c) ?d)
       ((equal x ?d) ?a)
       ((equal x ?x) ?y)
       ((equal x ?y) ?x)
       (t x)))

    (defun flip4 (x)
      (cond
       ((equal x ?a) ?c)
       ((equal x ?b) ?b)
       ((equal x ?c) ?a)
       ((equal x ?d) ?d)
       ((equal x ?x) ?y)
       ((equal x ?y) ?x)
       ((equal x ?s) ?t)
       ((equal x ?t) ?s)
       (t x)))

    (defun rotate3 (x)
      (cond
       ((equal x ?a) ?b)
       ((equal x ?b) ?c)
       ((equal x ?c) ?a)
       ((equal x ?x) ?y)
       ((equal x ?y) ?z)
       ((equal x ?z) ?x)
       (t x)))

    (defun flip3 (x)
      (cond
       ((equal x ?a) ?b)
       ((equal x ?b) ?a)
       ((equal x ?c) ?c)
       ((equal x ?d) ?d)
       ((equal x ?x) ?y)
       ((equal x ?y) ?x)
       ((equal x ?z) ?z)
       (t x)))


    (defun mapcar-string (transformation string sort)
      (let ((transformed (mapcar transformation string)))
	(if sort
	    (concat (sort transformed '<))
	  (concat transformed))))
   #+end_src

   #+RESULTS:
   : mapcar-string




* Visjs
  :PROPERTIES:
  :END:

  We use ~vis.js~ to take the ~dot~ file to create an interactive graph.
  ~vis.js~ needs the graph in ~dot~ format as a single(!) one-line string.

  The following piece of code reads our ~dot~ file (called ~file~) and converts it into such a string.
  The result is named ~dotstring~.
  #+name: dotstring
  #+begin_src elisp :results silent value :var file="artifacts/ttauta3.dot" :tangle no
    (with-temp-buffer
      (insert-file-contents file)
      (while (re-search-forward "\\[image=.*" nil t)
	(replace-match ";"))
      (string-join (split-string (buffer-string) "\n" t) " ")
      )
  #+end_src

  We now ask ~vis~ to parse this string, and we save the nodes and the edges as a ~DataSet~.
  #+begin_src javascript :noweb tangle
    var data = vis.parseDOTNetwork('<<dotstring()>>');
    var allNodes = new vis.DataSet(data.nodes);
    var allEdges = new vis.DataSet(data.edges);
  #+end_src
  
  The graph will live in an ~html~ file, whose skeleton we now create.
  #+begin_src html 
    <!DOCTYPE html>
    <html>
      <head>
	<title>A3 automaton</title>
	<script type="text/javascript" src="https://visjs.github.io/vis-network/standalone/umd/vis-network.min.js"></script>
	<style type="text/css">
	  html, body {
	  padding: 0;
	  margin: 10;
	  width: 100%;
	  height: 100%;
	  }

	  #graph {
	  width: 100%;
	  height: 100%;
	  }

	  mark.green {
	  color: green;
	  background: none;
	  }
	  mark.orange {
	  color: orange;
	  background: none;
	  }
	  mark.red {
	  color: red;
	  background: none;
	  }
	  mark.blue {
	  color: blue;
	  background: none;
	  }
	  mark.yellow {
	  color: darkkhaki;
	  background: none;
	  }
	</style>
      </head>

      <body>
	<div id="graph">
	</div>
	<script type="text/javascript" src="ttauta3.js"></script>
      </body>
    </html> 
  #+end_src

  The javascript modifies the ~graph~ division of the ~html~ file.
  #+begin_src javascript 
    var container = document.getElementById("graph");
  #+end_src
  
** Options
  We now create the look of our graph by setting the options for nodes ...
  #+begin_src javascript 
    var nodeoptions = {
	shape: 'box',
	margin: 10,
	font: '14px Helvetica',
    };
  #+end_src
  ... and edges. We set the default font size to 0 because we don't want to clutter the graph with edge labels.
  #+begin_src javascript 
    var edgeoptions = {
	font: {
	    size: 0,
	    align: 'top',
	},
	smooth: {
	    type: 'dynamic'
	},
    };
  #+end_src

  We enable physics.
  #+begin_src javascript
    var physicsoptions = {
	enabled: true,
	barnesHut: {
	    springLength: 500,
	    avoidOverlap: 1,
	    springConstant: 0.001
	}
    }
  #+end_src

  We arrange so that selecting a node does not automatically select all incident edges, which is the default.
  The rest of the options are self-explanatory.
  #+begin_src javascript 
    var options = {
	autoResize: true,
	height: '100%',
	width: '100%',
	interaction: {
	    selectConnectedEdges: false
	},
	nodes: nodeoptions,
	edges: edgeoptions,
	physics: physicsoptions
    }
  #+end_src
** Main dispatcher
  We now initialise the main network.
  #+begin_src javascript
    var network;
    network = new vis.Network(container, {nodes: allNodes, edges: allEdges}, options);

  #+end_src

** Event handlers
  To make our graph interactive, we create some event handling functions.
  We create helper functions to dim/undim nodes and edges.
  The dimming/undimming is done using a combination of opacity, font size, and font colour.
  #+begin_src javascript
    function undimNode(nodeid){
	return {
	    id: nodeid,
	    opacity: 1.0,
	    font:{
		color: 'black'
	    } 
	}
    }

    function dimNode(nodeid){
	return {
	    id: nodeid,
	    opacity: 0.01,
	    font:{
		color: 'rgb(225,225,225)'
	    } 
	}
    }

    function undimEdge(edgeid){
	return {
	    id: edgeid,
	    font: {
		size: 14,
	    },
	    width: 5,
	}
    }

    function dimEdge(edgeid, width=0){
	return {
	    id: edgeid,
	    font: {
		size: 0
	    },
	    width: width,
	}
    }

  #+end_src

  The following function handles the dimming and undimming.
  If a node is selected, it only keeps the selected nodes, their neighbors, and their incident edges.
  If no node is selected, it keeps everything.
  #+begin_src javascript
    function dimOrUnDim(params){
	if (params.nodes.length > 0){
	    var updateNodeArray = [];
	    var keepNodes = Array.from(params.nodes);
	    for (n of params.nodes)
		for (nodeid of network.getConnectedNodes(n))
		    keepNodes.push(nodeid);

	    //Dim all the nodes except the selected ones
	    for (nodeid of allNodes.getIds()){
		if (keepNodes.includes(nodeid))
		    updateNodeArray.push(undimNode(nodeid));
		else
		    updateNodeArray.push(dimNode(nodeid));
	    }

	    // Dim all the edges except the ones emnating from the selected vertex
	    var updateEdgeArray = [];
	    var keepEdges = Array.from(params.edges);
	    nodeid = params.nodes[0];
	    for (edgeid of network.getConnectedEdges(nodeid))
		if (allEdges.get(edgeid).from == nodeid)
		    keepEdges.push(edgeid)

	    for (edgeid of allEdges.getIds()){
		if (keepEdges.includes(edgeid))
		    updateEdgeArray.push(undimEdge(edgeid));
		else
		    updateEdgeArray.push(dimEdge(edgeid));
	    }

	}else{
	    //Undim all nodes
	    var updateNodeArray = [];
	    for (nodeid of allNodes.getIds())
		updateNodeArray.push(undimNode(nodeid));

	    //Dim all edges
	    var updateEdgeArray = [];
	    for (edgeid of allEdges.getIds())
		updateEdgeArray.push(dimEdge(edgeid, 1));
	}
	allNodes.update(updateNodeArray);
	allEdges.update(updateEdgeArray);    
    }
  #+end_src

  We now add the function above as a handler to the hold event.
  #+begin_src javascript
    network.on('hold', dimOrUnDim);
  #+end_src
